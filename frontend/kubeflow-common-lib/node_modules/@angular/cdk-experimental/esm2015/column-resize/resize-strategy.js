/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Inject, Injectable } from '@angular/core';
import { DOCUMENT } from '@angular/common';
import { coerceCssPixelValue } from '@angular/cdk/coercion';
import { CdkTable, _CoalescedStyleScheduler, _COALESCED_STYLE_SCHEDULER } from '@angular/cdk/table';
import { ColumnResize } from './column-resize';
/**
 * Provides an implementation for resizing a column.
 * The details of how resizing works for tables for flex mat-tables are quite different.
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from './column-resize';
import * as ɵngcc2 from '@angular/cdk/table';
export class ResizeStrategy {
    constructor() {
        this._pendingResizeDelta = null;
    }
    /** Adjusts the width of the table element by the specified delta. */
    updateTableWidthAndStickyColumns(delta) {
        var _a;
        if (this._pendingResizeDelta === null) {
            const tableElement = this.columnResize.elementRef.nativeElement;
            const tableWidth = getElementWidth(tableElement);
            this.styleScheduler.schedule(() => {
                tableElement.style.width = coerceCssPixelValue(tableWidth + this._pendingResizeDelta);
                this._pendingResizeDelta = null;
            });
            this.styleScheduler.scheduleEnd(() => {
                this.table.updateStickyColumnStyles();
            });
        }
        this._pendingResizeDelta = ((_a = this._pendingResizeDelta) !== null && _a !== void 0 ? _a : 0) + delta;
    }
}
ResizeStrategy.ɵfac = function ResizeStrategy_Factory(t) { return new (t || ResizeStrategy)(); };
ResizeStrategy.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: ResizeStrategy, factory: ResizeStrategy.ɵfac });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ResizeStrategy, [{
        type: Injectable
    }], function () { return []; }, null); })();
/**
 * The optimially performing resize strategy for &lt;table&gt; elements with table-layout: fixed.
 * Tested against and outperformed:
 *   CSS selector
 *   CSS selector w/ CSS variable
 *   Updating all cell nodes
 */
export class TableLayoutFixedResizeStrategy extends ResizeStrategy {
    constructor(columnResize, styleScheduler, table) {
        super();
        this.columnResize = columnResize;
        this.styleScheduler = styleScheduler;
        this.table = table;
    }
    applyColumnSize(_, columnHeader, sizeInPx, previousSizeInPx) {
        const delta = sizeInPx - (previousSizeInPx !== null && previousSizeInPx !== void 0 ? previousSizeInPx : getElementWidth(columnHeader));
        if (delta === 0) {
            return;
        }
        this.styleScheduler.schedule(() => {
            columnHeader.style.width = coerceCssPixelValue(sizeInPx);
        });
        this.updateTableWidthAndStickyColumns(delta);
    }
    applyMinColumnSize(_, columnHeader, sizeInPx) {
        const currentWidth = getElementWidth(columnHeader);
        const newWidth = Math.max(currentWidth, sizeInPx);
        this.applyColumnSize(_, columnHeader, newWidth, currentWidth);
    }
    applyMaxColumnSize(_, columnHeader, sizeInPx) {
        const currentWidth = getElementWidth(columnHeader);
        const newWidth = Math.min(currentWidth, sizeInPx);
        this.applyColumnSize(_, columnHeader, newWidth, currentWidth);
    }
}
TableLayoutFixedResizeStrategy.ɵfac = function TableLayoutFixedResizeStrategy_Factory(t) { return new (t || TableLayoutFixedResizeStrategy)(ɵngcc0.ɵɵinject(ɵngcc1.ColumnResize), ɵngcc0.ɵɵinject(_COALESCED_STYLE_SCHEDULER), ɵngcc0.ɵɵinject(ɵngcc2.CdkTable)); };
TableLayoutFixedResizeStrategy.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: TableLayoutFixedResizeStrategy, factory: TableLayoutFixedResizeStrategy.ɵfac });
TableLayoutFixedResizeStrategy.ctorParameters = () => [
    { type: ColumnResize },
    { type: _CoalescedStyleScheduler, decorators: [{ type: Inject, args: [_COALESCED_STYLE_SCHEDULER,] }] },
    { type: CdkTable }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TableLayoutFixedResizeStrategy, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc1.ColumnResize }, { type: ɵngcc2._CoalescedStyleScheduler, decorators: [{
                type: Inject,
                args: [_COALESCED_STYLE_SCHEDULER]
            }] }, { type: ɵngcc2.CdkTable }]; }, null); })();
/**
 * The optimally performing resize strategy for flex mat-tables.
 * Tested against and outperformed:
 *   CSS selector w/ CSS variable
 *   Updating all mat-cell nodes
 */
export class CdkFlexTableResizeStrategy extends ResizeStrategy {
    constructor(columnResize, styleScheduler, table, document) {
        super();
        this.columnResize = columnResize;
        this.styleScheduler = styleScheduler;
        this.table = table;
        this._columnIndexes = new Map();
        this._columnProperties = new Map();
        this._indexSequence = 0;
        this.defaultMinSize = 0;
        this.defaultMaxSize = Number.MAX_SAFE_INTEGER;
        this._document = document;
    }
    applyColumnSize(cssFriendlyColumnName, columnHeader, sizeInPx, previousSizeInPx) {
        // Optimization: Check applied width first as we probably set it already before reading
        // offsetWidth which triggers layout.
        const delta = sizeInPx - (previousSizeInPx !== null && previousSizeInPx !== void 0 ? previousSizeInPx : (this._getAppliedWidth(cssFriendlyColumnName) || columnHeader.offsetWidth));
        if (delta === 0) {
            return;
        }
        const cssSize = coerceCssPixelValue(sizeInPx);
        this._applyProperty(cssFriendlyColumnName, 'flex', `0 0.01 ${cssSize}`);
        this.updateTableWidthAndStickyColumns(delta);
    }
    applyMinColumnSize(cssFriendlyColumnName, _, sizeInPx) {
        const cssSize = coerceCssPixelValue(sizeInPx);
        this._applyProperty(cssFriendlyColumnName, 'min-width', cssSize, sizeInPx !== this.defaultMinSize);
        this.updateTableWidthAndStickyColumns(0);
    }
    applyMaxColumnSize(cssFriendlyColumnName, _, sizeInPx) {
        const cssSize = coerceCssPixelValue(sizeInPx);
        this._applyProperty(cssFriendlyColumnName, 'max-width', cssSize, sizeInPx !== this.defaultMaxSize);
        this.updateTableWidthAndStickyColumns(0);
    }
    getColumnCssClass(cssFriendlyColumnName) {
        return `cdk-column-${cssFriendlyColumnName}`;
    }
    ngOnDestroy() {
        // TODO: Use remove() once we're off IE11.
        if (this._styleElement && this._styleElement.parentNode) {
            this._styleElement.parentNode.removeChild(this._styleElement);
            this._styleElement = undefined;
        }
    }
    _getPropertyValue(cssFriendlyColumnName, key) {
        const properties = this._getColumnPropertiesMap(cssFriendlyColumnName);
        return properties.get(key);
    }
    _getAppliedWidth(cssFriendslyColumnName) {
        return coercePixelsFromFlexValue(this._getPropertyValue(cssFriendslyColumnName, 'flex'));
    }
    _applyProperty(cssFriendlyColumnName, key, value, enable = true) {
        const properties = this._getColumnPropertiesMap(cssFriendlyColumnName);
        this.styleScheduler.schedule(() => {
            if (enable) {
                properties.set(key, value);
            }
            else {
                properties.delete(key);
            }
            this._applySizeCss(cssFriendlyColumnName);
        });
    }
    _getStyleSheet() {
        if (!this._styleElement) {
            this._styleElement = this._document.createElement('style');
            this._styleElement.appendChild(this._document.createTextNode(''));
            this._document.head.appendChild(this._styleElement);
        }
        return this._styleElement.sheet;
    }
    _getColumnPropertiesMap(cssFriendlyColumnName) {
        let properties = this._columnProperties.get(cssFriendlyColumnName);
        if (properties === undefined) {
            properties = new Map();
            this._columnProperties.set(cssFriendlyColumnName, properties);
        }
        return properties;
    }
    _applySizeCss(cssFriendlyColumnName) {
        const properties = this._getColumnPropertiesMap(cssFriendlyColumnName);
        const propertyKeys = Array.from(properties.keys());
        let index = this._columnIndexes.get(cssFriendlyColumnName);
        if (index === undefined) {
            if (!propertyKeys.length) {
                // Nothing to set or unset.
                return;
            }
            index = this._indexSequence++;
            this._columnIndexes.set(cssFriendlyColumnName, index);
        }
        else {
            this._getStyleSheet().deleteRule(index);
        }
        const columnClassName = this.getColumnCssClass(cssFriendlyColumnName);
        const tableClassName = this.columnResize.getUniqueCssClass();
        const selector = `.${tableClassName} .${columnClassName}`;
        const body = propertyKeys.map(key => `${key}:${properties.get(key)}`).join(';');
        this._getStyleSheet().insertRule(`${selector} {${body}}`, index);
    }
}
CdkFlexTableResizeStrategy.ɵfac = function CdkFlexTableResizeStrategy_Factory(t) { return new (t || CdkFlexTableResizeStrategy)(ɵngcc0.ɵɵinject(ɵngcc1.ColumnResize), ɵngcc0.ɵɵinject(_COALESCED_STYLE_SCHEDULER), ɵngcc0.ɵɵinject(ɵngcc2.CdkTable), ɵngcc0.ɵɵinject(DOCUMENT)); };
CdkFlexTableResizeStrategy.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: CdkFlexTableResizeStrategy, factory: CdkFlexTableResizeStrategy.ɵfac });
CdkFlexTableResizeStrategy.ctorParameters = () => [
    { type: ColumnResize },
    { type: _CoalescedStyleScheduler, decorators: [{ type: Inject, args: [_COALESCED_STYLE_SCHEDULER,] }] },
    { type: CdkTable },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CdkFlexTableResizeStrategy, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc1.ColumnResize }, { type: ɵngcc2._CoalescedStyleScheduler, decorators: [{
                type: Inject,
                args: [_COALESCED_STYLE_SCHEDULER]
            }] }, { type: ɵngcc2.CdkTable }, { type: undefined, decorators: [{
                type: Inject,
                args: [DOCUMENT]
            }] }]; }, null); })();
/** Converts CSS pixel values to numbers, eg "123px" to 123. Returns NaN for non pixel values. */
function coercePixelsFromCssValue(cssValue) {
    var _a;
    return Number((_a = cssValue.match(/(\d+)px/)) === null || _a === void 0 ? void 0 : _a[1]);
}
/** Gets the style.width pixels on the specified element if present, otherwise its offsetWidth. */
function getElementWidth(element) {
    // Optimization: Check style.width first as we probably set it already before reading
    // offsetWidth which triggers layout.
    return coercePixelsFromCssValue(element.style.width) || element.offsetWidth;
}
/**
 * Converts CSS flex values as set in CdkFlexTableResizeStrategy to numbers,
 * eg "0 0.01 123px" to 123.
 */
function coercePixelsFromFlexValue(flexValue) {
    var _a;
    return Number((_a = flexValue === null || flexValue === void 0 ? void 0 : flexValue.match(/0 0\.01 (\d+)px/)) === null || _a === void 0 ? void 0 : _a[1]);
}
export const TABLE_LAYOUT_FIXED_RESIZE_STRATEGY_PROVIDER = {
    provide: ResizeStrategy,
    useClass: TableLayoutFixedResizeStrategy,
};
export const FLEX_RESIZE_STRATEGY_PROVIDER = {
    provide: ResizeStrategy,
    useClass: CdkFlexTableResizeStrategy,
};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVzaXplLXN0cmF0ZWd5LmpzIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9zcmMvY2RrLWV4cGVyaW1lbnRhbC9jb2x1bW4tcmVzaXplL3Jlc2l6ZS1zdHJhdGVneS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBRUgsT0FBTyxFQUFDLE1BQU0sRUFBRSxVQUFVLEVBQXNCLE1BQU0sZUFBZSxDQUFDO0FBQ3RFLE9BQU8sRUFBQyxRQUFRLEVBQUMsTUFBTSxpQkFBaUIsQ0FBQztBQUN6QyxPQUFPLEVBQUMsbUJBQW1CLEVBQUMsTUFBTSx1QkFBdUIsQ0FBQztBQUMxRCxPQUFPLEVBQUMsUUFBUSxFQUFFLHdCQUF3QixFQUFFLDBCQUEwQixFQUFDLE1BQU0sb0JBQW9CLENBQUM7QUFFbEcsT0FBTyxFQUFDLFlBQVksRUFBQyxNQUFNLGlCQUFpQixDQUFDO0FBRTdDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7Ozs7QUFFSCxNQUFNLE9BQWdCLGNBQWM7QUFDcEMsSUFGQTtBQUNFLFFBS1Esd0JBQW1CLEdBQWdCLElBQUksQ0FBQztBQUNsRCxJQXVDQSxDQUFDO0FBQ0QsSUFwQkUscUVBQXFFO0FBQ3ZFLElBQVksZ0NBQWdDLENBQUMsS0FBYTtBQUFJO0FBQ3BELFFBQU4sSUFBSSxJQUFJLENBQUMsbUJBQW1CLEtBQUssSUFBSSxFQUFFO0FBQzNDLFlBQU0sTUFBTSxZQUFZLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxVQUFVLENBQUMsYUFBYSxDQUFDO0FBQ3RFLFlBQU0sTUFBTSxVQUFVLEdBQUcsZUFBZSxDQUFDLFlBQVksQ0FBQyxDQUFDO0FBQ3ZELFlBQ00sSUFBSSxDQUFDLGNBQWMsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFO0FBQ3hDLGdCQUFRLFlBQVksQ0FBQyxLQUFLLENBQUMsS0FBSyxHQUFHLG1CQUFtQixDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUMsbUJBQW9CLENB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ZSxDQUFDLE9BQW9CO0FBQzdDLElBQUUscUZBQXFGO0FBQ3ZGLElBQUUscUNBQXFDO0FBQ3ZDLElBQUUsT0FBTyx3QkFBd0IsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxJQUFJLE9BQU8sQ0FBQyxXQUFXLENBQUM7QUFDOUUsQ0FBQztBQUVEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxTQUFTLHlCQUF5QixDQUFDLFNBQTJCO0FBQUk7QUFDOUQsSUFBRixPQUFPLE1BQU0sQ0FBQyxNQUFBLFNBQVMsYUFBVCxTQUFTLHVCQUFULFNBQVMsQ0FBRSxLQUFLLENBQUMsaUJBQWlCLENBQUMsMENBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUMxRCxDQUFDO0FBRUQsTUFBTSxDQUFDLE1BQU0sMkNBQTJDLEdBQWE7QUFDckUsSUFBRSxPQUFPLEVBQUUsY0FBYztBQUN6QixJQUFFLFFBQVEsRUFBRSw4QkFBOEI7QUFDMUMsQ0FBQyxDQUFDO0FBQ0YsTUFBTSxDQUFDLE1BQU0sNkJBQTZCLEdBQWE7QUFDdkQsSUFBRSxPQUFPLEVBQUUsY0FBYztBQUN6QixJQUFFLFFBQVEsRUFBRSwwQkFBMEI7QUFDdEMsQ0FBQyxDQUFDO0FBQ0YiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuaW1wb3J0IHtJbmplY3QsIEluamVjdGFibGUsIE9uRGVzdHJveSwgUHJvdmlkZXJ9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtET0NVTUVOVH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7Y29lcmNlQ3NzUGl4ZWxWYWx1ZX0gZnJvbSAnQGFuZ3VsYXIvY2RrL2NvZXJjaW9uJztcbmltcG9ydCB7Q2RrVGFibGUsIF9Db2FsZXNjZWRTdHlsZVNjaGVkdWxlciwgX0NPQUxFU0NFRF9TVFlMRV9TQ0hFRFVMRVJ9IGZyb20gJ0Bhbmd1bGFyL2Nkay90YWJsZSc7XG5cbmltcG9ydCB7Q29sdW1uUmVzaXplfSBmcm9tICcuL2NvbHVtbi1yZXNpemUnO1xuXG4vKipcbiAqIFByb3ZpZGVzIGFuIGltcGxlbWVudGF0aW9uIGZvciByZXNpemluZyBhIGNvbHVtbi5cbiAqIFRoZSBkZXRhaWxzIG9mIGhvdyByZXNpemluZyB3b3JrcyBmb3IgdGFibGVzIGZvciBmbGV4IG1hdC10YWJsZXMgYXJlIHF1aXRlIGRpZmZlcmVudC5cbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFJlc2l6ZVN0cmF0ZWd5IHtcbiAgcHJvdGVjdGVkIGFic3RyYWN0IHJlYWRvbmx5IGNvbHVtblJlc2l6ZTogQ29sdW1uUmVzaXplO1xuICBwcm90ZWN0ZWQgYWJzdHJhY3QgcmVhZG9ubHkgc3R5bGVTY2hlZHVsZXI6IF9Db2FsZXNjZWRTdHlsZVNjaGVkdWxlcjtcbiAgcHJvdGVjdGVkIGFic3RyYWN0IHJlYWRvbmx5IHRhYmxlOiBDZGtUYWJsZTx1bmtub3duPjtcblxuICBwcml2YXRlIF9wZW5kaW5nUmVzaXplRGVsdGE6IG51bWJlcnxudWxsID0gbnVsbDtcblxuICAvKiogVXBkYXRlcyB0aGUgd2lkdGggb2YgdGhlIHNwZWNpZmllZCBjb2x1bW4uICovXG4gIGFic3RyYWN0IGFwcGx5Q29sdW1uU2l6ZShcbiAgICAgIGNzc0ZyaWVuZGx5Q29sdW1uTmFtZTogc3RyaW5nLFxuICAgICAgY29sdW1uSGVhZGVyOiBIVE1MRWxlbWVudCxcbiAgICAgIHNpemVJblB4OiBudW1iZXIsXG4gICAgICBwcmV2aW91c1NpemVJblB4PzogbnVtYmVyKTogdm9pZDtcblxuICAvKiogQXBwbGllcyBhIG1pbmltdW0gd2lkdGggdG8gdGhlIHNwZWNpZmllZCBjb2x1bW4sIHVwZGF0aW5nIGl0cyBjdXJyZW50IHdpZHRoIGFzIG5lZWRlZC4gKi9cbiAgYWJzdHJhY3QgYXBwbHlNaW5Db2x1bW5TaXplKFxuICAgICAgY3NzRnJpZW5kbHlDb2x1bW5OYW1lOiBzdHJpbmcsXG4gICAgICBjb2x1bW5IZWFkZXI6IEhUTUxFbGVtZW50LFxuICAgICAgbWluU2l6ZUluUHg6IG51bWJlcik6IHZvaWQ7XG5cbiAgLyoqIEFwcGxpZXMgYSBtYXhpbXVtIHdpZHRoIHRvIHRoZSBzcGVjaWZpZWQgY29sdW1uLCB1cGRhdGluZyBpdHMgY3VycmVudCB3aWR0aCBhcyBuZWVkZWQuICovXG4gIGFic3RyYWN0IGFwcGx5TWF4Q29sdW1uU2l6ZShcbiAgICAgIGNzc0ZyaWVuZGx5Q29sdW1uTmFtZTogc3RyaW5nLFxuICAgICAgY29sdW1uSGVhZGVyOiBIVE1MRWxlbWVudCxcbiAgICAgIG1pblNpemVJblB4OiBudW1iZXIpOiB2b2lkO1xuXG4gIC8qKiBBZGp1c3RzIHRoZSB3aWR0aCBvZiB0aGUgdGFibGUgZWxlbWVudCBieSB0aGUgc3BlY2lmaWVkIGRlbHRhLiAqL1xuICBwcm90ZWN0ZWQgdXBkYXRlVGFibGVXaWR0aEFuZFN0aWNreUNvbHVtbnMoZGVsdGE6IG51bWJlcik6IHZvaWQge1xuICAgIGlmICh0aGlzLl9wZW5kaW5nUmVzaXplRGVsdGEgPT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHRhYmxlRWxlbWVudCA9IHRoaXMuY29sdW1uUmVzaXplLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcbiAgICAgIGNvbnN0IHRhYmxlV2lkdGggPSBnZXRFbGVtZW50V2lkdGgodGFibGVFbGVtZW50KTtcblxuICAgICAgdGhpcy5zdHlsZVNjaGVkdWxlci5zY2hlZHVsZSgoKSA9PiB7XG4gICAgICAgIHRhYmxlRWxlbWVudC5zdHlsZS53aWR0aCA9IGNvZXJjZUNzc1BpeGVsVmFsdWUodGFibGVXaWR0aCArIHRoaXMuX3BlbmRpbmdSZXNpemVEZWx0YSEpO1xuXG4gICAgICAgIHRoaXMuX3BlbmRpbmdSZXNpemVEZWx0YSA9IG51bGw7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5zdHlsZVNjaGVkdWxlci5zY2hlZHVsZUVuZCgoKSA9PiB7XG4gICAgICAgIHRoaXMudGFibGUudXBkYXRlU3RpY2t5Q29sdW1uU3R5bGVzKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLl9wZW5kaW5nUmVzaXplRGVsdGEgPSAodGhpcy5fcGVuZGluZ1Jlc2l6ZURlbHRhID8/IDApICsgZGVsdGE7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgb3B0aW1pYWxseSBwZXJmb3JtaW5nIHJlc2l6ZSBzdHJhdGVneSBmb3IgJmx0O3RhYmxlJmd0OyBlbGVtZW50cyB3aXRoIHRhYmxlLWxheW91dDogZml4ZWQuXG4gKiBUZXN0ZWQgYWdhaW5zdCBhbmQgb3V0cGVyZm9ybWVkOlxuICogICBDU1Mgc2VsZWN0b3JcbiAqICAgQ1NTIHNlbGVjdG9yIHcvIENTUyB2YXJpYWJsZVxuICogICBVcGRhdGluZyBhbGwgY2VsbCBub2Rlc1xuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgVGFibGVMYXlvdXRGaXhlZFJlc2l6ZVN0cmF0ZWd5IGV4dGVuZHMgUmVzaXplU3RyYXRlZ3kge1xuICBjb25zdHJ1Y3RvcihcbiAgICAgIHByb3RlY3RlZCByZWFkb25seSBjb2x1bW5SZXNpemU6IENvbHVtblJlc2l6ZSxcbiAgICAgIEBJbmplY3QoX0NPQUxFU0NFRF9TVFlMRV9TQ0hFRFVMRVIpXG4gICAgICAgICAgcHJvdGVjdGVkIHJlYWRvbmx5IHN0eWxlU2NoZWR1bGVyOiBfQ29hbGVzY2VkU3R5bGVTY2hlZHVsZXIsXG4gICAgICBwcm90ZWN0ZWQgcmVhZG9ubHkgdGFibGU6IENka1RhYmxlPHVua25vd24+KSB7XG4gICAgc3VwZXIoKTtcbiAgfVxuXG4gIGFwcGx5Q29sdW1uU2l6ZShfOiBzdHJpbmcsIGNvbHVtbkhlYWRlcjogSFRNTEVsZW1lbnQsIHNpemVJblB4OiBudW1iZXIsXG4gICAgICBwcmV2aW91c1NpemVJblB4PzogbnVtYmVyKTogdm9pZCB7XG4gICAgY29uc3QgZGVsdGEgPSBzaXplSW5QeCAtIChwcmV2aW91c1NpemVJblB4ID8/IGdldEVsZW1lbnRXaWR0aChjb2x1bW5IZWFkZXIpKTtcblxuICAgIGlmIChkZWx0YSA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuc3R5bGVTY2hlZHVsZXIuc2NoZWR1bGUoKCkgPT4ge1xuICAgICAgY29sdW1uSGVhZGVyLnN0eWxlLndpZHRoID0gY29lcmNlQ3NzUGl4ZWxWYWx1ZShzaXplSW5QeCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLnVwZGF0ZVRhYmxlV2lkdGhBbmRTdGlja3lDb2x1bW5zKGRlbHRhKTtcbiAgfVxuXG4gIGFwcGx5TWluQ29sdW1uU2l6ZShfOiBzdHJpbmcsIGNvbHVtbkhlYWRlcjogSFRNTEVsZW1lbnQsIHNpemVJblB4OiBudW1iZXIpOiB2b2lkIHtcbiAgICBjb25zdCBjdXJyZW50V2lkdGggPSBnZXRFbGVtZW50V2lkdGgoY29sdW1uSGVhZGVyKTtcbiAgICBjb25zdCBuZXdXaWR0aCA9IE1hdGgubWF4KGN1cnJlbnRXaWR0aCwgc2l6ZUluUHgpO1xuXG4gICAgdGhpcy5hcHBseUNvbHVtblNpemUoXywgY29sdW1uSGVhZGVyLCBuZXdXaWR0aCwgY3VycmVudFdpZHRoKTtcbiAgfVxuXG4gIGFwcGx5TWF4Q29sdW1uU2l6ZShfOiBzdHJpbmcsIGNvbHVtbkhlYWRlcjogSFRNTEVsZW1lbnQsIHNpemVJblB4OiBudW1iZXIpOiB2b2lkIHtcbiAgICBjb25zdCBjdXJyZW50V2lkdGggPSBnZXRFbGVtZW50V2lkdGgoY29sdW1uSGVhZGVyKTtcbiAgICBjb25zdCBuZXdXaWR0aCA9IE1hdGgubWluKGN1cnJlbnRXaWR0aCwgc2l6ZUluUHgpO1xuXG4gICAgdGhpcy5hcHBseUNvbHVtblNpemUoXywgY29sdW1uSGVhZGVyLCBuZXdXaWR0aCwgY3VycmVudFdpZHRoKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBvcHRpbWFsbHkgcGVyZm9ybWluZyByZXNpemUgc3RyYXRlZ3kgZm9yIGZsZXggbWF0LXRhYmxlcy5cbiAqIFRlc3RlZCBhZ2FpbnN0IGFuZCBvdXRwZXJmb3JtZWQ6XG4gKiAgIENTUyBzZWxlY3RvciB3LyBDU1MgdmFyaWFibGVcbiAqICAgVXBkYXRpbmcgYWxsIG1hdC1jZWxsIG5vZGVzXG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBDZGtGbGV4VGFibGVSZXNpemVTdHJhdGVneSBleHRlbmRzIFJlc2l6ZVN0cmF0ZWd5IGltcGxlbWVudHMgT25EZXN0cm95IHtcbiAgcHJpdmF0ZSByZWFkb25seSBfZG9jdW1lbnQ6IERvY3VtZW50O1xuICBwcml2YXRlIHJlYWRvbmx5IF9jb2x1bW5JbmRleGVzID0gbmV3IE1hcDxzdHJpbmcsIG51bWJlcj4oKTtcbiAgcHJpdmF0ZSByZWFkb25seSBfY29sdW1uUHJvcGVydGllcyA9IG5ldyBNYXA8c3RyaW5nLCBNYXA8c3RyaW5nLCBzdHJpbmc+PigpO1xuXG4gIHByaXZhdGUgX3N0eWxlRWxlbWVudD86IEhUTUxTdHlsZUVsZW1lbnQ7XG4gIHByaXZhdGUgX2luZGV4U2VxdWVuY2UgPSAwO1xuXG4gIHByb3RlY3RlZCByZWFkb25seSBkZWZhdWx0TWluU2l6ZSA9IDA7XG4gIHByb3RlY3RlZCByZWFkb25seSBkZWZhdWx0TWF4U2l6ZSA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgICAgcHJvdGVjdGVkIHJlYWRvbmx5IGNvbHVtblJlc2l6ZTogQ29sdW1uUmVzaXplLFxuICAgICAgQEluamVjdChfQ09BTEVTQ0VEX1NUWUxFX1NDSEVEVUxFUilcbiAgICAgICAgICBwcm90ZWN0ZWQgcmVhZG9ubHkgc3R5bGVTY2hlZHVsZXI6IF9Db2FsZXNjZWRTdHlsZVNjaGVkdWxlcixcbiAgICAgIHByb3RlY3RlZCByZWFkb25seSB0YWJsZTogQ2RrVGFibGU8dW5rbm93bj4sXG4gICAgICBASW5qZWN0KERPQ1VNRU5UKSBkb2N1bWVudDogYW55KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9kb2N1bWVudCA9IGRvY3VtZW50O1xuICB9XG5cbiAgYXBwbHlDb2x1bW5TaXplKGNzc0ZyaWVuZGx5Q29sdW1uTmFtZTogc3RyaW5nLCBjb2x1bW5IZWFkZXI6IEhUTUxFbGVtZW50LFxuICAgICAgc2l6ZUluUHg6IG51bWJlciwgcHJldmlvdXNTaXplSW5QeD86IG51bWJlcik6IHZvaWQge1xuICAgIC8vIE9wdGltaXphdGlvbjogQ2hlY2sgYXBwbGllZCB3aWR0aCBmaXJzdCBhcyB3ZSBwcm9iYWJseSBzZXQgaXQgYWxyZWFkeSBiZWZvcmUgcmVhZGluZ1xuICAgIC8vIG9mZnNldFdpZHRoIHdoaWNoIHRyaWdnZXJzIGxheW91dC5cbiAgICBjb25zdCBkZWx0YSA9IHNpemVJblB4IC0gKHByZXZpb3VzU2l6ZUluUHggPz9cbiAgICAgICAgKHRoaXMuX2dldEFwcGxpZWRXaWR0aChjc3NGcmllbmRseUNvbHVtbk5hbWUpIHx8IGNvbHVtbkhlYWRlci5vZmZzZXRXaWR0aCkpO1xuXG4gICAgaWYgKGRlbHRhID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY3NzU2l6ZSA9IGNvZXJjZUNzc1BpeGVsVmFsdWUoc2l6ZUluUHgpO1xuXG4gICAgdGhpcy5fYXBwbHlQcm9wZXJ0eShjc3NGcmllbmRseUNvbHVtbk5hbWUsICdmbGV4JywgYDAgMC4wMSAke2Nzc1NpemV9YCk7XG4gICAgdGhpcy51cGRhdGVUYWJsZVdpZHRoQW5kU3RpY2t5Q29sdW1ucyhkZWx0YSk7XG4gIH1cblxuICBhcHBseU1pbkNvbHVtblNpemUoY3NzRnJpZW5kbHlDb2x1bW5OYW1lOiBzdHJpbmcsIF86IEhUTUxFbGVtZW50LCBzaXplSW5QeDogbnVtYmVyKTogdm9pZCB7XG4gICAgY29uc3QgY3NzU2l6ZSA9IGNvZXJjZUNzc1BpeGVsVmFsdWUoc2l6ZUluUHgpO1xuXG4gICAgdGhpcy5fYXBwbHlQcm9wZXJ0eShjc3NGcmllbmRseUNvbHVtbk5hbWUsICdtaW4td2lkdGgnLCBjc3NTaXplLFxuICAgICAgICBzaXplSW5QeCAhPT0gdGhpcy5kZWZhdWx0TWluU2l6ZSk7XG4gICAgdGhpcy51cGRhdGVUYWJsZVdpZHRoQW5kU3RpY2t5Q29sdW1ucygwKTtcbiAgfVxuXG4gIGFwcGx5TWF4Q29sdW1uU2l6ZShjc3NGcmllbmRseUNvbHVtbk5hbWU6IHN0cmluZywgXzogSFRNTEVsZW1lbnQsIHNpemVJblB4OiBudW1iZXIpOiB2b2lkIHtcbiAgICBjb25zdCBjc3NTaXplID0gY29lcmNlQ3NzUGl4ZWxWYWx1ZShzaXplSW5QeCk7XG5cbiAgICB0aGlzLl9hcHBseVByb3BlcnR5KGNzc0ZyaWVuZGx5Q29sdW1uTmFtZSwgJ21heC13aWR0aCcsIGNzc1NpemUsXG4gICAgICAgIHNpemVJblB4ICE9PSB0aGlzLmRlZmF1bHRNYXhTaXplKTtcbiAgICB0aGlzLnVwZGF0ZVRhYmxlV2lkdGhBbmRTdGlja3lDb2x1bW5zKDApO1xuICB9XG5cbiAgcHJvdGVjdGVkIGdldENvbHVtbkNzc0NsYXNzKGNzc0ZyaWVuZGx5Q29sdW1uTmFtZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYGNkay1jb2x1bW4tJHtjc3NGcmllbmRseUNvbHVtbk5hbWV9YDtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgIC8vIFRPRE86IFVzZSByZW1vdmUoKSBvbmNlIHdlJ3JlIG9mZiBJRTExLlxuICAgIGlmICh0aGlzLl9zdHlsZUVsZW1lbnQgJiYgdGhpcy5fc3R5bGVFbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgIHRoaXMuX3N0eWxlRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuX3N0eWxlRWxlbWVudCk7XG4gICAgICB0aGlzLl9zdHlsZUVsZW1lbnQgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfZ2V0UHJvcGVydHlWYWx1ZShjc3NGcmllbmRseUNvbHVtbk5hbWU6IHN0cmluZywga2V5OiBzdHJpbmcpOiBzdHJpbmd8dW5kZWZpbmVkIHtcbiAgICBjb25zdCBwcm9wZXJ0aWVzID0gdGhpcy5fZ2V0Q29sdW1uUHJvcGVydGllc01hcChjc3NGcmllbmRseUNvbHVtbk5hbWUpO1xuICAgIHJldHVybiBwcm9wZXJ0aWVzLmdldChrZXkpO1xuICB9XG5cbiAgcHJpdmF0ZSBfZ2V0QXBwbGllZFdpZHRoKGNzc0ZyaWVuZHNseUNvbHVtbk5hbWU6IHN0cmluZyk6IG51bWJlciB7XG4gICAgcmV0dXJuIGNvZXJjZVBpeGVsc0Zyb21GbGV4VmFsdWUodGhpcy5fZ2V0UHJvcGVydHlWYWx1ZShjc3NGcmllbmRzbHlDb2x1bW5OYW1lLCAnZmxleCcpKTtcbiAgfVxuXG4gIHByaXZhdGUgX2FwcGx5UHJvcGVydHkoXG4gICAgICBjc3NGcmllbmRseUNvbHVtbk5hbWU6IHN0cmluZyxcbiAgICAgIGtleTogc3RyaW5nLFxuICAgICAgdmFsdWU6IHN0cmluZyxcbiAgICAgIGVuYWJsZSA9IHRydWUpOiB2b2lkIHtcbiAgICBjb25zdCBwcm9wZXJ0aWVzID0gdGhpcy5fZ2V0Q29sdW1uUHJvcGVydGllc01hcChjc3NGcmllbmRseUNvbHVtbk5hbWUpO1xuXG4gICAgdGhpcy5zdHlsZVNjaGVkdWxlci5zY2hlZHVsZSgoKSA9PiB7XG4gICAgICBpZiAoZW5hYmxlKSB7XG4gICAgICAgIHByb3BlcnRpZXMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvcGVydGllcy5kZWxldGUoa2V5KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2FwcGx5U2l6ZUNzcyhjc3NGcmllbmRseUNvbHVtbk5hbWUpO1xuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBfZ2V0U3R5bGVTaGVldCgpOiBDU1NTdHlsZVNoZWV0IHtcbiAgICBpZiAoIXRoaXMuX3N0eWxlRWxlbWVudCkge1xuICAgICAgdGhpcy5fc3R5bGVFbGVtZW50ID0gdGhpcy5fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICAgIHRoaXMuX3N0eWxlRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJykpO1xuICAgICAgdGhpcy5fZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCh0aGlzLl9zdHlsZUVsZW1lbnQpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9zdHlsZUVsZW1lbnQuc2hlZXQgYXMgQ1NTU3R5bGVTaGVldDtcbiAgfVxuXG4gIHByaXZhdGUgX2dldENvbHVtblByb3BlcnRpZXNNYXAoY3NzRnJpZW5kbHlDb2x1bW5OYW1lOiBzdHJpbmcpOiBNYXA8c3RyaW5nLCBzdHJpbmc+IHtcbiAgICBsZXQgcHJvcGVydGllcyA9IHRoaXMuX2NvbHVtblByb3BlcnRpZXMuZ2V0KGNzc0ZyaWVuZGx5Q29sdW1uTmFtZSk7XG4gICAgaWYgKHByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcHJvcGVydGllcyA9IG5ldyBNYXA8c3RyaW5nLCBzdHJpbmc+KCk7XG4gICAgICB0aGlzLl9jb2x1bW5Qcm9wZXJ0aWVzLnNldChjc3NGcmllbmRseUNvbHVtbk5hbWUsIHByb3BlcnRpZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcGVydGllcztcbiAgfVxuXG4gIHByaXZhdGUgX2FwcGx5U2l6ZUNzcyhjc3NGcmllbmRseUNvbHVtbk5hbWU6IHN0cmluZykge1xuICAgIGNvbnN0IHByb3BlcnRpZXMgPSB0aGlzLl9nZXRDb2x1bW5Qcm9wZXJ0aWVzTWFwKGNzc0ZyaWVuZGx5Q29sdW1uTmFtZSk7XG4gICAgY29uc3QgcHJvcGVydHlLZXlzID0gQXJyYXkuZnJvbShwcm9wZXJ0aWVzLmtleXMoKSk7XG5cbiAgICBsZXQgaW5kZXggPSB0aGlzLl9jb2x1bW5JbmRleGVzLmdldChjc3NGcmllbmRseUNvbHVtbk5hbWUpO1xuICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoIXByb3BlcnR5S2V5cy5sZW5ndGgpIHtcbiAgICAgICAgLy8gTm90aGluZyB0byBzZXQgb3IgdW5zZXQuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaW5kZXggPSB0aGlzLl9pbmRleFNlcXVlbmNlKys7XG4gICAgICB0aGlzLl9jb2x1bW5JbmRleGVzLnNldChjc3NGcmllbmRseUNvbHVtbk5hbWUsIGluZGV4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZ2V0U3R5bGVTaGVldCgpLmRlbGV0ZVJ1bGUoaW5kZXgpO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbHVtbkNsYXNzTmFtZSA9IHRoaXMuZ2V0Q29sdW1uQ3NzQ2xhc3MoY3NzRnJpZW5kbHlDb2x1bW5OYW1lKTtcbiAgICBjb25zdCB0YWJsZUNsYXNzTmFtZSA9IHRoaXMuY29sdW1uUmVzaXplLmdldFVuaXF1ZUNzc0NsYXNzKCk7XG5cbiAgICBjb25zdCBzZWxlY3RvciA9IGAuJHt0YWJsZUNsYXNzTmFtZX0gLiR7Y29sdW1uQ2xhc3NOYW1lfWA7XG4gICAgY29uc3QgYm9keSA9IHByb3BlcnR5S2V5cy5tYXAoa2V5ID0+IGAke2tleX06JHtwcm9wZXJ0aWVzLmdldChrZXkpfWApLmpvaW4oJzsnKTtcblxuICAgIHRoaXMuX2dldFN0eWxlU2hlZXQoKS5pbnNlcnRSdWxlKGAke3NlbGVjdG9yfSB7JHtib2R5fX1gLCBpbmRleCEpO1xuICB9XG59XG5cbi8qKiBDb252ZXJ0cyBDU1MgcGl4ZWwgdmFsdWVzIHRvIG51bWJlcnMsIGVnIFwiMTIzcHhcIiB0byAxMjMuIFJldHVybnMgTmFOIGZvciBub24gcGl4ZWwgdmFsdWVzLiAqL1xuZnVuY3Rpb24gY29lcmNlUGl4ZWxzRnJvbUNzc1ZhbHVlKGNzc1ZhbHVlOiBzdHJpbmcpOiBudW1iZXIge1xuICByZXR1cm4gTnVtYmVyKGNzc1ZhbHVlLm1hdGNoKC8oXFxkKylweC8pPy5bMV0pO1xufVxuXG4vKiogR2V0cyB0aGUgc3R5bGUud2lkdGggcGl4ZWxzIG9uIHRoZSBzcGVjaWZpZWQgZWxlbWVudCBpZiBwcmVzZW50LCBvdGhlcndpc2UgaXRzIG9mZnNldFdpZHRoLiAqL1xuZnVuY3Rpb24gZ2V0RWxlbWVudFdpZHRoKGVsZW1lbnQ6IEhUTUxFbGVtZW50KSB7XG4gIC8vIE9wdGltaXphdGlvbjogQ2hlY2sgc3R5bGUud2lkdGggZmlyc3QgYXMgd2UgcHJvYmFibHkgc2V0IGl0IGFscmVhZHkgYmVmb3JlIHJlYWRpbmdcbiAgLy8gb2Zmc2V0V2lkdGggd2hpY2ggdHJpZ2dlcnMgbGF5b3V0LlxuICByZXR1cm4gY29lcmNlUGl4ZWxzRnJvbUNzc1ZhbHVlKGVsZW1lbnQuc3R5bGUud2lkdGgpIHx8IGVsZW1lbnQub2Zmc2V0V2lkdGg7XG59XG5cbi8qKlxuICogQ29udmVydHMgQ1NTIGZsZXggdmFsdWVzIGFzIHNldCBpbiBDZGtGbGV4VGFibGVSZXNpemVTdHJhdGVneSB0byBudW1iZXJzLFxuICogZWcgXCIwIDAuMDEgMTIzcHhcIiB0byAxMjMuXG4gKi9cbmZ1bmN0aW9uIGNvZXJjZVBpeGVsc0Zyb21GbGV4VmFsdWUoZmxleFZhbHVlOiBzdHJpbmd8dW5kZWZpbmVkKTogbnVtYmVyIHtcbiAgcmV0dXJuIE51bWJlcihmbGV4VmFsdWU/Lm1hdGNoKC8wIDBcXC4wMSAoXFxkKylweC8pPy5bMV0pO1xufVxuXG5leHBvcnQgY29uc3QgVEFCTEVfTEFZT1VUX0ZJWEVEX1JFU0laRV9TVFJBVEVHWV9QUk9WSURFUjogUHJvdmlkZXIgPSB7XG4gIHByb3ZpZGU6IFJlc2l6ZVN0cmF0ZWd5LFxuICB1c2VDbGFzczogVGFibGVMYXlvdXRGaXhlZFJlc2l6ZVN0cmF0ZWd5LFxufTtcbmV4cG9ydCBjb25zdCBGTEVYX1JFU0laRV9TVFJBVEVHWV9QUk9WSURFUjogUHJvdmlkZXIgPSB7XG4gIHByb3ZpZGU6IFJlc2l6ZVN0cmF0ZWd5LFxuICB1c2VDbGFzczogQ2RrRmxleFRhYmxlUmVzaXplU3RyYXRlZ3ksXG59O1xuIl19