{"version":3,"file":"node.js","sourceRoot":"","sources":["../../../src/lib/graph/node.ts"],"names":[],"mappings":";;;AAEa,QAAA,WAAW,GAAc,OAAO,CAAC;AACjC,QAAA,iBAAiB,GAAc,aAAa,CAAC;AAC7C,QAAA,aAAa,GAAc,SAAS,CAAC;AACrC,QAAA,UAAU,GAAc,MAAM,CAAC;AAE5C;;GAEG;AACH,MAAa,IAAI;IACf,YAA4B,GAAW;QAAX,QAAG,GAAH,GAAG,CAAQ;QAMhC,UAAK,GAAc,EAAE,CAAC;QAsBrB,gBAAW,GAAG,IAAI,GAAG,EAAQ,CAAC;QAC9B,eAAU,GAAG,IAAI,GAAG,EAAQ,CAAC;IA7BK,CAAC;IAQpC,MAAM,CAAC,EAA2C;QACvD,OAAO,CAAC,GAAG,IAAI,CAAC,WAAW,CAAC,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;IAC1C,CAAC;IAEM,IAAI,CAAC,EAA2C;QACrD,OAAO,CAAC,GAAG,IAAI,CAAC,WAAW,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;IACxC,CAAC;IAEM,IAAI,CAAC,EAA2C;QACrD,OAAO,CAAC,GAAG,IAAI,CAAC,WAAW,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;IACxC,CAAC;IAED,IAAW,UAAU;QACnB,OAAO,IAAI,CAAC,WAAW,CAAC;IAC1B,CAAC;IAED,IAAW,SAAS;QAClB,OAAO,IAAI,CAAC,UAAU,CAAC;IACzB,CAAC;IAKD,2IAA2I;IACpI,SAAS,CAAC,SAAwB;QACvC,MAAM,OAAO,GAAG,KAAK,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC;QAEnE,KAAK,MAAM,MAAM,IAAI,OAAO,EAAE;YAC5B,IAAI,MAAM,CAAC,UAAU,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE;gBAC/B,sCAAsC;gBACtC,SAAS;aACV;YAED,MAAM,CAAC,UAAU,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;YAC5B,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;SAC9B;IACH,CAAC;CACF;AA9CD,oBA8CC","sourcesContent":["export type NodeState = '' | 'dirty' | 'in-progress' | 'pending' | 'done';\n\nexport const STATE_DIRTY: NodeState = 'dirty';\nexport const STATE_IN_PROGRESS: NodeState = 'in-progress';\nexport const STATE_PENDING: NodeState = 'pending';\nexport const STATE_DONE: NodeState = 'done';\n\n/**\n * A Node in the {@link BuildGraph}.\n */\nexport class Node {\n  constructor(public readonly url: string) {}\n\n  public type: string;\n\n  public data: any;\n\n  public state: NodeState = '';\n\n  public filter(by: (value: Node, index: number) => boolean): Node[] {\n    return [...this._dependents].filter(by);\n  }\n\n  public find(by: (value: Node, index: number) => boolean): Node | undefined {\n    return [...this._dependents].find(by);\n  }\n\n  public some(by: (value: Node, index: number) => boolean): boolean {\n    return [...this._dependents].some(by);\n  }\n\n  public get dependents(): Set<Node> {\n    return this._dependents;\n  }\n\n  public get dependees(): Set<Node> {\n    return this._dependees;\n  }\n\n  private _dependents = new Set<Node>();\n  private _dependees = new Set<Node>();\n\n  /** @experimental DO NOT USE. For time being, dirty checking is for `type=entryPoint && state !== 'done'` (full rebuild of entry point). */\n  public dependsOn(dependent: Node | Node[]) {\n    const newDeps = Array.isArray(dependent) ? dependent : [dependent];\n\n    for (const newDep of newDeps) {\n      if (newDep._dependees.has(this)) {\n        // nodes already depends on each other\n        continue;\n      }\n\n      newDep._dependees.add(this);\n      this._dependents.add(newDep);\n    }\n  }\n}\n"]}